// 부호 있는 자료형의 비트 연산 알아보기.c
#include <stdio.h>

int main() {
    unsigned char num1 = 131; // 131: 1000 0011
    char num2 = -125; // -125: 1000 0011

    unsigned char num3;
    char num4;

    num3 = num1 >> 5; // num1의 비트 값을 오른쪽으로 5번 이동
    num4 = num2 >> 5; // num2의 비트 값을 오른쪽으로 5번 이동

    printf("%u\n", num3); // 4: 0000 0100: 맨 뒤의 11은 사라지고 0000 0100이 됨
    printf("%d\n", num4); // -4: 1111 1100: 모자라는 공간은 부호 비트의 값인 1로 채워지므로 1111 1100이 됨

    char num5 = 67; // 67: 0100 0011
    char num6;

    num6 = num5 >> 5; // num5의 비트 값을 오른쪽으로 5번 이동

    printf("%d\n", num6); // 2: 0000 0010: 모자라는 공간은 부호 비트의 값인 0으로 채워지므로 0000 0010이 됨

    char num7 = 113; // 113: 0111 0001
    char num8 = -15; // -15: 1111 0001
    char num9, num10, num11, num12;

    num9 = num7 << 2; // num7의 비트 값을 왼쪽으로 2번 이동
    num10 = num8 << 2; // num8의 비트 값을 왼쪽으로 2번 이동

    num11 = num7 << 4; // num7의 비트 값을 왼쪽으로 4번 이동 
    num12 = num8 << 4; // num8의 비트 값을 왼쪽으로 4번 이동

    printf("%d\n", num9); // -60: 1100 0100: 부호 비트를 덮어쓰게 되므로 양수에서 음수가 됨
    printf("%d\n", num10); // -60: 1100 0100: 이미 음수인 수는 계속 음수가 됨

    printf("%d\n", num11); // 16: 0001 0000: 이미 양수인 수는 계속 양수가 됨
    printf("%d\n", num12); // 16: 0001 0000: 부호 비트를 덮어쓰게 되므로 음수에서 양수가 됨

    return 0;
}